#!/usr/bin/env tsx
import * as fs from 'fs';
import * as path from 'path';
import { Project, SourceFile, Node } from 'ts-morph';

interface RouteInfo {
  filePath: string;
  routePath: string;
  methods: string[];
  hasTypeExport: boolean;
}

interface GeneratedType {
  name: string;
  method: string;
  routePath: string;
  typeDefinition: string;
}

/**
 * Convert file path to API route path
 * e.g., "apps/[id]/route.ts" -> "/apps/{id}"
 */
function filePathToRoutePath(filePath: string): string {
  const relativePath = filePath
    .replace(/^.*\/api\/v1\//, '')
    .replace(/\/route\.ts$/, '')
    .replace(/\[([^\]]+)\]/g, '{$1}'); // Convert [id] to {id}

  return relativePath ? `/${relativePath}` : '';
}

/**
 * Generate type name from route path and method
 */
function generateTypeName(routePath: string, method: string): string {
  const cleanPath = routePath
    .replace(/^\//, '') // Remove leading slash
    .replace(/\{([^}]+)\}/g, 'By$1') // Convert {id} to ById
    .replace(/-([a-z])/g, (_, letter) => letter.toUpperCase()) // Convert kebab-case to camelCase
    .split('/')
    .map(segment => segment.charAt(0).toUpperCase() + segment.slice(1))
    .join('');

  const prefix =
    method.toLowerCase() === 'get'
      ? 'Get'
      : method.toLowerCase() === 'post'
        ? 'Create'
        : method.toLowerCase() === 'put'
          ? 'Update'
          : method.toLowerCase() === 'delete'
            ? 'Delete'
            : method.charAt(0).toUpperCase() + method.slice(1).toLowerCase();

  return `${prefix}${cleanPath || 'Root'}Response`;
}

/**
 * Find all route files in the API directory
 */
function findRouteFiles(apiDir: string): RouteInfo[] {
  const routes: RouteInfo[] = [];

  function scanDirectory(dir: string) {
    const items = fs.readdirSync(dir);

    for (const item of items) {
      const fullPath = path.join(dir, item);
      const stat = fs.statSync(fullPath);

      if (stat.isDirectory() && !item.startsWith('_')) {
        scanDirectory(fullPath);
      } else if (item === 'route.ts') {
        const relativePath = path.relative(apiDir, fullPath);
        const routePath = filePathToRoutePath(relativePath);

        routes.push({
          filePath: fullPath,
          routePath,
          methods: [], // Will be populated later
          hasTypeExport: false,
        });
      }
    }
  }

  scanDirectory(apiDir);
  return routes;
}

/**
 * Analyze a route file to extract methods and check for type exports
 */
function analyzeRouteFile(
  project: Project,
  routeInfo: RouteInfo
): GeneratedType[] {
  const sourceFile = project.addSourceFileAtPath(routeInfo.filePath);
  const generatedTypes: GeneratedType[] = [];

  // Find exported route handlers (GET, POST, PUT, DELETE, etc.)
  const exportedDeclarations = sourceFile.getExportedDeclarations();

  for (const [name, declarations] of exportedDeclarations) {
    if (['GET', 'POST', 'PUT', 'DELETE', 'PATCH'].includes(name)) {
      routeInfo.methods.push(name);

      // Check if there's already a Body type export for this method
      const bodyTypeName = name === 'GET' ? 'Body' : `${name}Body`;
      const hasExistingType = exportedDeclarations.has(bodyTypeName);

      if (!hasExistingType) {
        // Generate the type definition
        const typeName = generateTypeName(routeInfo.routePath, name);
        const typeDefinition = `export type ${typeName} = typeof ${name} extends OriginalRouteHandler<infer T> ? T : never;`;

        generatedTypes.push({
          name: typeName,
          method: name,
          routePath: routeInfo.routePath,
          typeDefinition,
        });
      } else {
        routeInfo.hasTypeExport = true;
      }
    }
  }

  // Remove the source file from project to avoid memory issues
  project.removeSourceFile(sourceFile);

  return generatedTypes;
}

/**
 * Generate the complete types file content
 */
function generateTypesFileContent(
  generatedTypes: GeneratedType[],
  apiDir: string
): string {
  const imports = `import { OriginalRouteHandler } from '../app/api/_utils/types';

// Auto-generated API response types
// This file is generated by running: npm run generate-api-types
// Do not edit this file manually - it will be overwritten

`;

  const typesByRoute = generatedTypes.reduce(
    (acc, type) => {
      if (!acc[type.routePath]) {
        acc[type.routePath] = [];
      }
      acc[type.routePath].push(type);
      return acc;
    },
    {} as Record<string, GeneratedType[]>
  );

  let content = imports;

  // Generate imports for each route
  const routeImports: string[] = [];
  for (const [routePath, types] of Object.entries(typesByRoute)) {
    for (const type of types) {
      const routeImportPath = routePath.replace(/\{[^}]+\}/g, '[id]'); // Convert back to Next.js format
      const importPath = `../app/api/v1${routeImportPath}/route`;
      const importAlias = `${type.method}${routePath.replace(/[^a-zA-Z0-9]/g, '')}`;

      routeImports.push(
        `import { ${type.method} as ${importAlias} } from '${importPath}';`
      );
    }
  }

  content += routeImports.join('\n') + '\n\n';

  for (const [routePath, types] of Object.entries(typesByRoute)) {
    content += `// Route: ${routePath || '/'}\n`;

    for (const type of types) {
      const importAlias = `${type.method}${routePath.replace(/[^a-zA-Z0-9]/g, '')}`;
      const typeDefinition = `export type ${type.name} = typeof ${importAlias} extends OriginalRouteHandler<infer T> ? T : never;`;
      content += `${typeDefinition}\n`;
    }

    content += '\n';
  }

  return content;
}

/**
 * Main function to generate API types
 */
async function main() {
  const apiDir = path.join(__dirname, '../src/app/api/v1');
  const outputFile = path.join(__dirname, '../src/generated/api-types.ts');

  console.log('üîç Scanning API routes...');

  // Create output directory if it doesn't exist
  const outputDir = path.dirname(outputFile);
  if (!fs.existsSync(outputDir)) {
    fs.mkdirSync(outputDir, { recursive: true });
  }

  // Create TypeScript project for analysis
  const project = new Project({
    tsConfigFilePath: path.join(__dirname, '../tsconfig.json'),
  });

  // Find all route files
  const routes = findRouteFiles(apiDir);
  console.log(`üìÅ Found ${routes.length} route files`);

  // Analyze each route file
  const allGeneratedTypes: GeneratedType[] = [];

  for (const route of routes) {
    try {
      const types = analyzeRouteFile(project, route);
      allGeneratedTypes.push(...types);

      if (types.length > 0) {
        console.log(
          `‚úÖ ${route.routePath || '/'}: Generated ${types.length} types`
        );
      } else if (route.hasTypeExport) {
        console.log(`‚è≠Ô∏è  ${route.routePath || '/'}: Already has type exports`);
      } else {
        console.log(`‚ö†Ô∏è  ${route.routePath || '/'}: No types generated`);
      }
    } catch (error) {
      console.error(`‚ùå Error analyzing ${route.filePath}:`, error);
    }
  }

  // Generate and write the types file
  if (allGeneratedTypes.length > 0) {
    const content = generateTypesFileContent(allGeneratedTypes, apiDir);
    fs.writeFileSync(outputFile, content, 'utf8');

    console.log(
      `\nüéâ Generated ${allGeneratedTypes.length} API response types`
    );
    console.log(
      `üìù Output written to: ${path.relative(process.cwd(), outputFile)}`
    );
  } else {
    console.log(
      '\n‚ö†Ô∏è  No new types generated - all routes may already have type exports'
    );
  }
}

// Run the script
if (require.main === module) {
  main().catch(console.error);
}
